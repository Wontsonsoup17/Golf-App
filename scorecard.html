<!DOCTYPE html>
<html lang="en">
<head>
<style>html,body{background:#0a0f0d}</style>
<script>
(function(){var v='135';var k='app_v';var s=localStorage.getItem(k);if(s&&s!==v){localStorage.setItem(k,v);window.location.replace(window.location.pathname+'?_='+Date.now());return;}localStorage.setItem(k,v);})();
</script>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0f0d">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>Live Round - Westchester Golf</title>
<link rel="stylesheet" href="shared.css?v=140">
</head>
<body>

<div class="header" id="pageHeader">
  <h1 id="courseName">Live Round</h1>
  <div class="subtitle" id="courseSub"></div>
</div>

<div class="main" id="mainContent"></div>

<!-- Mulligan location modal -->
<div class="modal-overlay" id="mulliganModal">
  <div class="modal">
    <h3 id="mulliganModalTitle">Mulligan Recap</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:16px">Where did you take each mulligan?</p>
    <div id="mulliganModalBody"></div>
    <div class="modal-actions">
      <button class="btn-gold" id="mulliganDoneBtn" onclick="confirmMulliganLocations()">Done</button>
    </div>
  </div>
</div>

<nav class="bottom-nav" id="bottomNav"></nav>
<div style="text-align:center;font-size:9px;color:#333;padding:4px;opacity:0.5">v106</div>

<script src="firebase-config.js?v=140"></script>
<script src="shared.js?v=140"></script>
<script src="firebase-sync.js?v=140"></script>
<script>
  // ==================== SCORE EFFECTS (emoji burst) ====================
  // Defined at script scope so both solo and group modes can access them
  function getScoreEffectTier(score, par) {
    if (!score || score <= 0) return null;
    if (score === 1) return { name: 'Hole-in-One!', emoji: 'üèÜ', holdTime: 2800, cssClass: 'ace' };
    var diff = score - par;
    if (diff <= -3) return { name: 'Albatross!', emoji: 'ü¶Ö', holdTime: 2600, cssClass: 'eagle' };
    if (diff === -2) return { name: 'Eagle!', emoji: 'ü¶Ö', holdTime: 2400, cssClass: 'eagle' };
    if (diff === -1) return { name: 'Birdie!', emoji: 'üê¶', holdTime: 2200, cssClass: 'birdie' };
    if (diff === 0) return { name: 'Par', emoji: '‚õ≥', holdTime: 2000, cssClass: 'par-score' };
    if (diff === 1) return { name: 'Bogey', emoji: 'üò¨', holdTime: 2000, cssClass: 'bogey' };
    if (diff === 2) return { name: 'Double Bogey', emoji: 'üíÄ', holdTime: 2000, cssClass: 'double-plus' };
    return { name: 'Triple+', emoji: 'üßëüèΩ‚Äçü¶º', holdTime: 2200, cssClass: 'double-plus' };
  }

  // Shows effect and calls onDone when animation is fully finished
  function showScoreEffect(score, par, onDone) {
    var tier = getScoreEffectTier(score, par);
    if (!tier) { if (onDone) onDone(); return; }
    var container = spawnEmojiBurst(tier);
    // Wait for grid to fill in, then show the announcement inside the container
    var popInTime = 600;
    setTimeout(function() {
      var el = document.createElement('div');
      el.className = 'score-announce';
      el.innerHTML = '<span class="score-announce-emoji">' + tier.emoji + '</span>' +
                     '<span class="score-announce-text ' + tier.cssClass + '">' + tier.name + '</span>';
      container.appendChild(el);
    }, popInTime);
    // Hold the filled screen, then fade everything out together, then advance
    setTimeout(function() {
      container.classList.add('fade-out');
      setTimeout(function() {
        if (container.parentNode) container.parentNode.removeChild(container);
        if (onDone) onDone();
      }, 500);
    }, popInTime + tier.holdTime);
  }

  function spawnEmojiBurst(tier) {
    var container = document.createElement('div');
    container.className = 'score-effect-container';
    document.body.appendChild(container);

    // Calculate grid to fill the viewport
    var vw = window.innerWidth;
    var vh = window.innerHeight;
    var cellSize = 50;
    var cols = Math.ceil(vw / cellSize) + 1;
    var rows = Math.ceil(vh / cellSize) + 1;
    var total = cols * rows;
    var fontSize = cellSize;

    // Shuffled delay indices for random pop-in wave
    var indices = [];
    for (var n = 0; n < total; n++) indices.push(n);
    for (var s = indices.length - 1; s > 0; s--) {
      var j = Math.floor(Math.random() * (s + 1));
      var tmp = indices[s]; indices[s] = indices[j]; indices[j] = tmp;
    }

    var maxDelay = 0.5;
    for (var i = 0; i < total; i++) {
      var row = Math.floor(i / cols);
      var col = i % cols;
      var p = document.createElement('div');
      p.className = 'emoji-burst-particle';
      p.textContent = tier.emoji;
      // Explicit inline position and size ‚Äî no CSS variables
      p.style.left = (col * cellSize) + 'px';
      p.style.top = (row * cellSize) + 'px';
      p.style.width = cellSize + 'px';
      p.style.height = cellSize + 'px';
      p.style.fontSize = fontSize + 'px';
      p.style.animationDelay = ((indices[i] / total) * maxDelay).toFixed(3) + 's';
      container.appendChild(p);
    }

    return container;
  }

  requireAuth(function(user) {
    renderBottomNav('courses');

    const urlParams = new URLSearchParams(window.location.search);
    let groupCode = urlParams.get('group');

    // If no group code in URL, check localStorage for active group
    if (!groupCode) {
      const storedCode = localStorage.getItem('active-group-code');
      if (storedCode) groupCode = storedCode;
    }

    if (groupCode) {
      initGroupRound(user, groupCode);
    } else {
      // No local group code ‚Äî check Firebase for any round this user is in
      findActiveRoundForUser(user.uid).then(function(found) {
        if (found) {
          localStorage.setItem('active-group-code', found.code);
          initGroupRound(user, found.code);
        } else {
          initSoloRound(user);
        }
      });
    }
  });

  // ===================================================================
  // SHARED ‚Äî Mulligan Location Modal (used by both solo and group)
  // ===================================================================
  var pendingHoleIdx = null;
  var mulliganModalMode = null; // 'solo' or 'group'
  var mulliganModalPlayer = null; // player name (solo) or null (group)
  var _mulliganConfirmCallback = null; // set by each mode to handle post-confirm

  function ensureMulliganModal() {
    if (document.getElementById('mulliganModal')) return;
    // Inject styles if old cached CSS doesn't have them
    if (!document.getElementById('mulliganStyles')) {
      var style = document.createElement('style');
      style.id = 'mulliganStyles';
      style.textContent =
        '.mulligan-item{margin-bottom:16px}.mulligan-item:last-child{margin-bottom:0}' +
        '.mulligan-label{font-size:12px;font-weight:700;color:#d4af37;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px}' +
        '.mulligan-options{display:flex;gap:6px}' +
        '.mulligan-option{flex:1;padding:10px 6px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:#0a0f0d;color:#999;font-size:11px;font-weight:600;cursor:pointer;text-align:center;transition:all 0.15s ease}' +
        '.mulligan-option.selected{border-color:#d4af37;background:rgba(212,175,55,0.15);color:#d4af37}' +
        '@keyframes shake{0%,100%{transform:translateX(0)}20%,60%{transform:translateX(-4px)}40%,80%{transform:translateX(4px)}}';
      document.head.appendChild(style);
    }
    // Create modal dynamically so it works even if old HTML is cached
    var overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'mulliganModal';
    overlay.innerHTML =
      '<div class="modal">' +
        '<h3 id="mulliganModalTitle">Mulligan Recap</h3>' +
        '<p style="font-size:13px;color:var(--text-dim);margin-bottom:16px">Where did you take each mulligan?</p>' +
        '<div id="mulliganModalBody"></div>' +
        '<div class="modal-actions">' +
          '<button class="btn-gold" id="mulliganDoneBtn" onclick="confirmMulliganLocations()">Done</button>' +
        '</div>' +
      '</div>';
    document.body.appendChild(overlay);
  }

  function showMulliganModal(playerName, count, holeIdx) {
    ensureMulliganModal();
    var modal = document.getElementById('mulliganModal');
    var body = document.getElementById('mulliganModalBody');
    document.getElementById('mulliganModalTitle').textContent = 'Hole ' + (holeIdx + 1) + ' ‚Äî Mulligans';
    var html = '';
    for (var i = 0; i < count; i++) {
      html += '<div class="mulligan-item">';
      html += '<div class="mulligan-label">Mulligan ' + (i + 1) + '</div>';
      html += '<div class="mulligan-options" data-index="' + i + '">';
      html += '<button class="mulligan-option" data-value="tee" onclick="selectMulliganLoc(this)">Off the Tee</button>';
      html += '<button class="mulligan-option" data-value="fairway" onclick="selectMulliganLoc(this)">On the Fairway</button>';
      html += '<button class="mulligan-option" data-value="green" onclick="selectMulliganLoc(this)">On the Green</button>';
      html += '</div></div>';
    }
    body.innerHTML = html;
    modal.classList.add('show');
  }

  window.selectMulliganLoc = function(btn) {
    var siblings = btn.parentElement.querySelectorAll('.mulligan-option');
    siblings.forEach(function(s) { s.classList.remove('selected'); });
    btn.classList.add('selected');
  };

  window.confirmMulliganLocations = function() {
    var groups = document.querySelectorAll('#mulliganModalBody .mulligan-options');
    var locations = [];
    var allSelected = true;
    groups.forEach(function(g) {
      var sel = g.querySelector('.mulligan-option.selected');
      if (!sel) { allSelected = false; }
      else { locations.push(sel.getAttribute('data-value')); }
    });
    if (!allSelected) {
      var btn = document.getElementById('mulliganDoneBtn');
      btn.style.animation = 'none';
      btn.offsetHeight;
      btn.style.animation = 'shake 0.3s ease';
      return;
    }
    // Close modal
    document.getElementById('mulliganModal').classList.remove('show');
    // Callback handles saving + advancing
    if (_mulliganConfirmCallback) {
      _mulliganConfirmCallback(locations);
      _mulliganConfirmCallback = null;
    }
  };

  // ===================================================================
  // SHARED ‚Äî Drop Location Modal (used by both solo and group)
  // ===================================================================
  var _dropConfirmCallback = null;

  function ensureDropModal() {
    if (document.getElementById('dropModal')) return;
    if (!document.getElementById('dropStyles')) {
      var style = document.createElement('style');
      style.id = 'dropStyles';
      style.textContent =
        '.drop-item{margin-bottom:16px}.drop-item:last-child{margin-bottom:0}' +
        '.drop-label{font-size:12px;font-weight:700;color:#e53935;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px}' +
        '.drop-options{display:flex;gap:6px}' +
        '.drop-option{flex:1;padding:10px 6px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:#0a0f0d;color:#999;font-size:11px;font-weight:600;cursor:pointer;text-align:center;transition:all 0.15s ease}' +
        '.drop-option.selected{border-color:#e53935;background:rgba(229,57,53,0.15);color:#e53935}';
      document.head.appendChild(style);
    }
    var overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'dropModal';
    overlay.innerHTML =
      '<div class="modal">' +
        '<h3 id="dropModalTitle">Drop Recap</h3>' +
        '<p style="font-size:13px;color:var(--text-dim);margin-bottom:16px">What was each drop for?</p>' +
        '<div id="dropModalBody"></div>' +
        '<div class="modal-actions">' +
          '<button class="btn-gold" id="dropDoneBtn" onclick="confirmDropLocations()" style="background:#e53935">Done</button>' +
        '</div>' +
      '</div>';
    document.body.appendChild(overlay);
  }

  function showDropModal(playerName, count, holeIdx) {
    ensureDropModal();
    var modal = document.getElementById('dropModal');
    var body = document.getElementById('dropModalBody');
    document.getElementById('dropModalTitle').textContent = 'Hole ' + (holeIdx + 1) + ' ‚Äî Drops';
    var html = '';
    for (var i = 0; i < count; i++) {
      html += '<div class="drop-item">';
      html += '<div class="drop-label">Drop ' + (i + 1) + '</div>';
      html += '<div class="drop-options" data-index="' + i + '">';
      html += '<button class="drop-option" data-value="water" onclick="selectDropLoc(this)">Water</button>';
      html += '<button class="drop-option" data-value="ob" onclick="selectDropLoc(this)">OB</button>';
      html += '<button class="drop-option" data-value="lateral" onclick="selectDropLoc(this)">Lateral</button>';
      html += '<button class="drop-option" data-value="unplayable" onclick="selectDropLoc(this)">Unplayable</button>';
      html += '</div></div>';
    }
    body.innerHTML = html;
    modal.classList.add('show');
  }

  window.selectDropLoc = function(btn) {
    var siblings = btn.parentElement.querySelectorAll('.drop-option');
    siblings.forEach(function(s) { s.classList.remove('selected'); });
    btn.classList.add('selected');
  };

  window.confirmDropLocations = function() {
    var groups = document.querySelectorAll('#dropModalBody .drop-options');
    var locations = [];
    var allSelected = true;
    groups.forEach(function(g) {
      var sel = g.querySelector('.drop-option.selected');
      if (!sel) { allSelected = false; }
      else { locations.push(sel.getAttribute('data-value')); }
    });
    if (!allSelected) {
      var btn = document.getElementById('dropDoneBtn');
      btn.style.animation = 'none';
      btn.offsetHeight;
      btn.style.animation = 'shake 0.3s ease';
      return;
    }
    document.getElementById('dropModal').classList.remove('show');
    if (_dropConfirmCallback) {
      _dropConfirmCallback(locations);
      _dropConfirmCallback = null;
    }
  };

  // ===================================================================
  // SOLO MODE ‚Äî existing localStorage-based play (mostly unchanged)
  // ===================================================================
  function initSoloRound(user) {
    let R = getActiveRound();

    if (!R) {
      document.getElementById('mainContent').innerHTML = `
        <div class="empty-state">
          <div class="icon">&#127948;</div>
          <p>No active round.<br><a href="index.html">Choose a course</a> to start playing.</p>
        </div>
      `;
      return;
    }

    const course = getCourse(R.courseId);
    let currentHole = R.currentHole || 0;

    // Apply sunset theme for "other" courses
    if (course && course.group === 'other') {
      document.body.classList.add('sunset-theme');
      document.querySelector('meta[name="theme-color"]').content = '#0f0a07';
    }

    if (!R.tracking) {
      R.tracking = {};
      R.players.forEach(p => R.tracking[p] = createPlayerTracking());
      save();
    }
    // Backfill mulliganLocations and penaltyLocations for older rounds
    R.players.forEach(p => {
      if (R.tracking[p] && !R.tracking[p].mulliganLocations) {
        R.tracking[p].mulliganLocations = new Array(18).fill(null);
      }
      if (R.tracking[p] && !R.tracking[p].penaltyLocations) {
        R.tracking[p].penaltyLocations = new Array(18).fill(null);
      }
    });

    document.getElementById('courseName').textContent = course.name;
    document.getElementById('courseSub').textContent = `${R.teeLabel} Tees  |  Par ${course.par}  |  ${formatDate(R.date)}`;

    // Auto-set current hole to par if unscored on initial load
    const initHole = course.holes[currentHole];
    R.players.forEach(p => {
      if (R.scores[p][currentHole] === 0) {
        R.scores[p][currentHole] = initHole.par;
      }
    });

    function save() {
      R.currentHole = currentHole;
      setActiveRound(R);
    }

    // Determine the current playable hole ‚Äî the first hole with no score for any player
    function getPlayableHole() {
      for (let i = 0; i < 18; i++) {
        const allScored = R.players.every(p => R.scores[p][i] > 0);
        if (!allScored) return i;
      }
      return 17; // all holes scored
    }

    function render() {
      const hole = course.holes[currentHole];
      const teeKey = R.tee;
      const yardage = hole[teeKey] || '‚Äî';
      const playableHole = getPlayableHole();
      const isFutureHole = currentHole > playableHole;

      let html = '';

      // Leaderboard link
      html += '<a href="live-game.html" class="leaderboard-link">&#127942; View Leaderboard</a>';

      // Hole strip
      html += '<div class="hole-strip" id="holeStrip">';
      for (let i = 0; i < 18; i++) {
        const anyScored = R.players.some(p => R.scores[p][i] > 0);
        let cls = i === currentHole ? 'active' : (anyScored ? 'scored' : '');
        if (i > playableHole && i !== currentHole) cls += ' future';
        html += `<div class="hole-pip ${cls}" onclick="goToHole(${i})">${i+1}</div>`;
      }
      html += '</div>';

      // Hole display
      html += `
        <div class="hole-display">
          <div class="hole-number">${isFutureHole ? 'Preview ‚Äî ' : ''}Hole ${hole.num}</div>
          <div class="hole-info-chips">
            <span class="info-chip par-chip">Par ${hole.par}</span>
            <span class="info-chip">${yardage} yds</span>
            <span class="info-chip">HCP ${hole.hcp}</span>
          </div>
        </div>
      `;

      // Future hole preview banner
      if (isFutureHole) {
        html += `<div class="preview-banner">
          <span class="preview-banner-icon">&#128065;</span>
          <div>
            <div class="preview-banner-title">Hole Preview</div>
            <div class="preview-banner-sub">You're previewing a future hole. Score input is available when you reach this hole.</div>
          </div>
          <button class="preview-back-btn" onclick="goToHole(${playableHole})">Go to Hole ${playableHole + 1} &#8594;</button>
        </div>`;
      }

      // Hole layout image
      if (hole.img) {
        html += `<div class="hole-layout-container" id="layoutContainer">
          <div class="hole-layout-toggle" onclick="document.getElementById('layoutContainer').classList.toggle('expanded')">
            <span class="layout-icon">üó∫Ô∏è</span>
            <span class="layout-label">View Hole Layout</span>
            <span class="layout-chevron">‚ñº</span>
          </div>
          <div class="hole-layout-img-wrap">
            <img src="${hole.img}" alt="Hole ${hole.num} layout" loading="lazy">
          </div>
        </div>`;
      }

      // Player cards ‚Äî only show if NOT a future hole
      if (!isFutureHole) {
        R.players.forEach((p, pIdx) => {
          const score = R.scores[p][currentHole];
          const scoreClass = getScoreClass(score, hole.par);
          const label = getScoreLabel(score, hole.par);
          const t = R.tracking[p];

          const totalScore = R.scores[p].reduce((a, b) => a + b, 0);
          const holesPlayed = R.scores[p].filter(s => s > 0).length;
          const parPlayed = course.holes.filter((h, i) => R.scores[p][i] > 0).reduce((a, h) => a + h.par, 0);
          const diff = totalScore - parPlayed;
          let badgeClass = 'even', badgeText = 'E';
          if (holesPlayed === 0) { badgeText = '‚Äî'; }
          else if (diff < 0) { badgeClass = 'under'; badgeText = diff.toString(); }
          else if (diff > 0) { badgeClass = 'over'; badgeText = '+' + diff; }

          const pSafe = p.replace(/'/g, "\\'");

          html += `
            <div class="player-score-card" data-player="${pSafe}">
              <div class="player-score-header">
                <span class="player-score-name">${p}</span>
                <span class="player-total-badge ${badgeClass}">${holesPlayed > 0 ? totalScore + ' (' + badgeText + ')' : '‚Äî'}</span>
              </div>
              <div class="score-stepper">
                <button class="step-btn minus" onclick="adj('${pSafe}', -1)">&minus;</button>
                <div class="score-big ${scoreClass}">${score || '‚Äî'}</div>
                <button class="step-btn plus" onclick="adj('${pSafe}', 1)">+</button>
              </div>
              <div class="score-label ${scoreClass}">${label}</div>
              <div class="putts-row">
                <span class="putts-label">‚õ≥Ô∏è Putts</span>
                <div class="putt-stepper">
                  <button class="putt-btn p-minus" onclick="adjPutt('${pSafe}', -1)">&minus;</button>
                  <div class="putt-val">${t.putts[currentHole]}</div>
                  <button class="putt-btn p-plus" onclick="adjPutt('${pSafe}', 1)">+</button>
                </div>
              </div>
              <div class="putts-row mulligan-row">
                <span class="putts-label mulligan-label-text">üîÑ Mulligan</span>
                <div class="putt-stepper">
                  <button class="putt-btn p-minus mulligan-btn" onclick="adjMulligan('${pSafe}', -1)">&minus;</button>
                  <div class="putt-val mulligan-val">${t.mulligans[currentHole]}</div>
                  <button class="putt-btn p-plus mulligan-btn" onclick="adjMulligan('${pSafe}', 1)">+</button>
                </div>
              </div>
              <div class="putts-row penalty-row">
                <span class="putts-label penalty-label-text">ü´≥üèº Drop</span>
                <div class="putt-stepper">
                  <button class="putt-btn p-minus penalty-btn" onclick="adjPenalty('${pSafe}', -1)">&minus;</button>
                  <div class="putt-val penalty-val">${t.penalties[currentHole]}</div>
                  <button class="putt-btn p-plus penalty-btn" onclick="adjPenalty('${pSafe}', 1)">+</button>
                </div>
              </div>
            </div>
          `;

          // Hole nav buttons ‚Äî right after the first player's score counter
          if (pIdx === 0) {
            html += '<div class="hole-nav-row">';
            if (currentHole > 0) {
              html += `<button class="hole-nav-btn prev" onclick="goToHole(${currentHole - 1})">&larr; Hole ${currentHole}</button>`;
            } else {
              html += '<div></div>';
            }
            if (currentHole < 17) {
              html += `<button class="hole-nav-btn next" onclick="goToHole(${currentHole + 1})">Hole ${currentHole + 2} &rarr;</button>`;
            } else {
              html += `<button class="hole-nav-btn next" onclick="finishRound()" style="background:var(--gold);color:#1a1a1a;">Finish Round</button>`;
            }
            html += '</div>';
          }
        });
      }

      if (!isFutureHole) {
        html += `
          <div class="finish-section">
            <button class="btn-gold" onclick="finishRound()">Save & Finish</button>
            <button class="btn-secondary" onclick="cancelRound()">Cancel</button>
          </div>
        `;
      }

      document.getElementById('mainContent').innerHTML = html;

      setTimeout(() => {
        const strip = document.getElementById('holeStrip');
        const activePip = strip?.querySelector('.hole-pip.active');
        if (activePip && strip) {
          activePip.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
        }
      }, 50);
    }

    // Check for pending drop locations, then advance
    function checkDropsThenAdvance(idx) {
      var playerWithDrops = null;
      R.players.forEach(function(p) {
        var count = R.tracking[p].penalties[currentHole];
        var pl = R.tracking[p].penaltyLocations;
        if (count > 0 && !(pl && pl[currentHole])) {
          playerWithDrops = p;
        }
      });
      if (playerWithDrops) {
        var holeAtPrompt = currentHole;
        var p = playerWithDrops;
        if (!R.tracking[p].penaltyLocations) {
          R.tracking[p].penaltyLocations = new Array(18).fill(null);
        }
        _dropConfirmCallback = function(locations) {
          R.tracking[p].penaltyLocations[holeAtPrompt] = locations;
          save();
          proceedToHole(idx);
        };
        showDropModal(p, R.tracking[p].penalties[currentHole], currentHole);
        return;
      }
      proceedToHole(idx);
    }

    window.goToHole = function(idx) {
      // Check if moving forward ‚Äî prompt for mulligan locations, then drop locations
      if (idx > currentHole) {
        var playerWithMulligans = null;
        R.players.forEach(function(p) {
          var count = R.tracking[p].mulligans[currentHole];
          var ml = R.tracking[p].mulliganLocations;
          if (count > 0 && !(ml && ml[currentHole])) {
            playerWithMulligans = p;
          }
        });
        if (playerWithMulligans) {
          var holeAtPrompt = currentHole;
          var p = playerWithMulligans;
          if (!R.tracking[p].mulliganLocations) {
            R.tracking[p].mulliganLocations = new Array(18).fill(null);
          }
          _mulliganConfirmCallback = function(locations) {
            R.tracking[p].mulliganLocations[holeAtPrompt] = locations;
            save();
            checkDropsThenAdvance(idx);
          };
          showMulliganModal(p, R.tracking[p].mulligans[currentHole], currentHole);
          return;
        }
        // No mulligans pending ‚Äî check drops
        checkDropsThenAdvance(idx);
        return;
      }
      proceedToHole(idx);
    };

    function proceedToHole(idx) {
      // Show score effect when moving forward, wait for it to finish
      if (idx > currentHole) {
        var prevPar = course.holes[currentHole].par;
        var prevScore = R.scores[R.players[0]][currentHole];
        if (prevScore > 0) {
          showScoreEffect(prevScore, prevPar, function() {
            doAdvanceHole(idx);
          });
          return;
        }
      }
      doAdvanceHole(idx);
    }
    function doAdvanceHole(idx) {
      currentHole = idx;
      const hole = course.holes[currentHole];
      R.players.forEach(p => {
        if (R.scores[p][currentHole] === 0) {
          R.scores[p][currentHole] = hole.par;
        }
      });
      save(); render(); window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    // Surgical DOM updates for solo mode (no full re-render, no scroll jump)
    function updateSoloCard(player) {
      const card = document.querySelector('.player-score-card[data-player="' + player.replace(/'/g, "\\'") + '"]');
      if (!card) return;
      const hole = course.holes[currentHole];
      const score = R.scores[player][currentHole];
      const scoreClass = getScoreClass(score, hole.par);
      const label = getScoreLabel(score, hole.par);
      const t = R.tracking[player];

      const scoreBig = card.querySelector('.score-big');
      if (scoreBig) { scoreBig.textContent = score || '‚Äî'; scoreBig.className = 'score-big ' + scoreClass; }

      const scoreLabel = card.querySelector('.score-label');
      if (scoreLabel) { scoreLabel.textContent = label; scoreLabel.className = 'score-label ' + scoreClass; }

      const totalScore = R.scores[player].reduce((a, b) => a + b, 0);
      const holesPlayed = R.scores[player].filter(s => s > 0).length;
      const parPlayed = course.holes.filter((h, i) => R.scores[player][i] > 0).reduce((a, h) => a + h.par, 0);
      const diff = totalScore - parPlayed;
      let badgeClass = 'even', badgeText = 'E';
      if (holesPlayed === 0) { badgeText = '‚Äî'; }
      else if (diff < 0) { badgeClass = 'under'; badgeText = diff.toString(); }
      else if (diff > 0) { badgeClass = 'over'; badgeText = '+' + diff; }

      const badge = card.querySelector('.player-total-badge');
      if (badge) { badge.className = 'player-total-badge ' + badgeClass; badge.textContent = holesPlayed > 0 ? totalScore + ' (' + badgeText + ')' : '‚Äî'; }

      const puttVal = card.querySelector('.putt-val');
      if (puttVal) puttVal.textContent = t.putts[currentHole];

      const mulliganVal = card.querySelector('.mulligan-val');
      if (mulliganVal) mulliganVal.textContent = t.mulligans[currentHole];

      const penaltyVal = card.querySelector('.penalty-val');
      if (penaltyVal) penaltyVal.textContent = t.penalties[currentHole];
    }

    window.adj = function(player, delta) { R.scores[player][currentHole] = Math.max(1, Math.min(15, R.scores[player][currentHole] + delta)); save(); updateSoloCard(player); };
    window.adjPutt = function(player, delta) { R.tracking[player].putts[currentHole] = Math.max(0, Math.min(10, R.tracking[player].putts[currentHole] + delta)); save(); updateSoloCard(player); };
    window.adjMulligan = function(player, delta) {
      var current = R.tracking[player].mulligans[currentHole];
      R.tracking[player].mulligans[currentHole] = Math.max(0, Math.min(5, current + delta));
      if (!R.tracking[player].mulliganLocations) R.tracking[player].mulliganLocations = new Array(18).fill(null);
      R.tracking[player].mulliganLocations[currentHole] = null;
      save(); updateSoloCard(player);
    };
    window.adjPenalty = function(player, delta) {
      var current = R.tracking[player].penalties[currentHole];
      R.tracking[player].penalties[currentHole] = Math.max(0, Math.min(10, current + delta));
      if (!R.tracking[player].penaltyLocations) R.tracking[player].penaltyLocations = new Array(18).fill(null);
      R.tracking[player].penaltyLocations[currentHole] = null;
      save(); updateSoloCard(player);
    };

    window.finishRound = function() {
      const anyScored = R.players.some(p => R.scores[p].some(s => s > 0));
      if (!anyScored) { alert('No scores entered yet.'); return; }

      // Check if any player has incomplete holes
      const anyIncomplete = R.players.some(p => R.scores[p].filter(s => s > 0).length < 18);
      const confirmMsg = anyIncomplete
        ? 'Some holes are incomplete. Save as incomplete round?'
        : 'Finish and save this round?';
      if (!confirm(confirmMsg)) return;

      // Build holesCompleted per player
      const holesCompleted = {};
      R.players.forEach(function(p) {
        holesCompleted[p] = R.scores[p].filter(s => s > 0).length;
      });

      const round = {
        id: Date.now().toString(),
        courseId: course.id,
        courseName: course.name,
        tee: R.tee,
        teeLabel: R.teeLabel,
        par: course.par,
        date: R.date,
        players: [...R.players],
        scores: JSON.parse(JSON.stringify(R.scores)),
        tracking: JSON.parse(JSON.stringify(R.tracking)),
        holePars: course.holes.map(h => h.par),
        holesCompleted: holesCompleted,
        incomplete: anyIncomplete
      };

      // Save to localStorage
      const rounds = loadRounds();
      rounds.push(round);
      saveRounds(rounds);

      // Also save to Firebase
      const currentUser = getCurrentUser();
      if (currentUser) {
        fbSaveRound(currentUser.uid, round).catch(() => {});
      }

      clearActiveRound();
      window.location.href = 'history.html';
    };

    window.cancelRound = function() {
      if (confirm('Cancel this round? All data will be lost.')) {
        clearActiveRound();
        window.location.href = 'index.html';
      }
    };

    render();
  }

  // ===================================================================
  // GROUP MODE ‚Äî Firebase real-time play
  // ===================================================================
  function initGroupRound(user, groupCode) {
    const course_ref = { current: null }; // populated from meta
    let currentHole = 0;
    let R = null; // round data built from Firebase
    let unsubscribe = null;
    let unsubConn = null;
    let isConnected = true;

    // Store group code locally for resume
    localStorage.setItem('active-group-code', groupCode);

    // Connection status
    unsubConn = listenConnectionStatus(connected => {
      isConnected = connected;
      const el = document.getElementById('connStatus');
      if (el) {
        el.className = 'connection-status ' + (connected ? 'online' : 'offline');
        el.innerHTML = `<span class="connection-dot"></span>${connected ? 'Live' : 'Offline'}`;
      }
    });

    let initialRenderDone = false;

    // First check if this player already finished this round
    isPlayerFinished(groupCode, user.uid).then(function(finished) {
      if (finished) {
        // Player already finished ‚Äî don't let them back in
        localStorage.removeItem('active-group-code');
        document.getElementById('mainContent').innerHTML =
          '<div class="empty-state">' +
            '<div class="icon">&#9989;</div>' +
            '<p>You already finished this round.<br>Your scores have been saved.</p>' +
            '<a href="history.html" style="display:inline-block;margin-top:14px;padding:12px 24px;background:var(--green-accent);color:#0a0f0d;border-radius:10px;font-weight:700;text-decoration:none">View History</a>' +
          '</div>';
        return;
      }

      // Not finished ‚Äî proceed with normal real-time listener
      startGroupListener();
    }).catch(function() {
      // If check fails (e.g. round deleted), proceed normally ‚Äî listener will handle it
      startGroupListener();
    });

    function startGroupListener() {
    var roundEndedHandled = false;
    // Listen for real-time updates
    unsubscribe = listenToGroupRound(groupCode, function(data) {
      // Round deleted from Firebase (all players finished and cleanup ran)
      if (!data) {
        localStorage.removeItem('active-group-code');
        return;
      }
      if (!data.meta) return;

      // Detect admin-ended round for non-admin players
      if (data.meta.status === 'ended' && data.meta.createdBy !== user.uid && !roundEndedHandled) {
        roundEndedHandled = true;
        // Wrap in IIFE to avoid variable name conflicts with outer scope
        (function() {
          var tempR = groupDataToRound(data, groupCode);
          var endedCourse = getCourse(tempR.courseId);
          if (endedCourse) {
            var myName = tempR._uidToName[user.uid];
            var myHolesPlayed = myName ? tempR.scores[myName].filter(function(s) { return s > 0; }).length : 0;
            var holesCompleted = {};
            tempR.players.forEach(function(p) {
              holesCompleted[p] = tempR.scores[p].filter(function(s) { return s > 0; }).length;
            });

            var round = {
              id: Date.now().toString(),
              courseId: endedCourse.id,
              courseName: endedCourse.name,
              tee: tempR.tee,
              teeLabel: tempR.teeLabel,
              par: endedCourse.par,
              date: tempR.date,
              players: tempR.players.slice(),
              scores: JSON.parse(JSON.stringify(tempR.scores)),
              tracking: JSON.parse(JSON.stringify(tempR.tracking)),
              holePars: endedCourse.holes.map(function(h) { return h.par; }),
              groupCode: groupCode,
              holesCompleted: holesCompleted,
              incomplete: myHolesPlayed < 18
            };

            fbSaveRound(user.uid, round).catch(function() {});
            var rounds = loadRounds();
            rounds.push(round);
            saveRounds(rounds);
          }
        })();

        // Clean up and redirect
        if (unsubscribe) unsubscribe();
        if (unsubConn) unsubConn();
        localStorage.removeItem('active-group-code');
        alert('The admin has ended the round. Your scores have been saved.');
        window.location.href = 'history.html';
        return;
      }

      R = groupDataToRound(data, groupCode);
      const course = getCourse(R.courseId);
      course_ref.current = course;

      if (!course) {
        document.getElementById('mainContent').innerHTML = '<div class="empty-state"><p>Course not found.</p></div>';
        return;
      }

      // Apply sunset theme for "other" courses
      if (course.group === 'other') {
        document.body.classList.add('sunset-theme');
        document.querySelector('meta[name="theme-color"]').content = '#0f0a07';
      }

      // Update header
      document.getElementById('courseName').textContent = course.name;
      document.getElementById('courseSub').textContent = `${R.teeLabel} Tees  |  Par ${course.par}  |  ${formatDate(R.date)}`;

      if (!initialRenderDone) {
        // First load ‚Äî full render
        initialRenderDone = true;
        renderGroup();
      } else {
        // Subsequent updates from other users ‚Äî only update the players leaderboard
        updatePlayersLeaderboard();
      }
    });
    } // end startGroupListener

    // Determine the current playable hole for the current user
    function getGroupPlayableHole() {
      const myName = R._uidToName[user.uid];
      if (!myName) return 0;
      const course = course_ref.current;
      if (!course) return 0;
      for (let i = 0; i < 18; i++) {
        if (!(R.scores[myName][i] > 0)) return i;
      }
      return 17;
    }

    // Build the players leaderboard HTML
    function buildPlayersLeaderboard(roundData, course, myName) {
      let lhtml = '<div id="playersLeaderboard" style="background:var(--bg-card);border-radius:var(--radius);border:1px solid var(--border);margin-bottom:12px;overflow:hidden">';
      lhtml += '<div style="padding:10px 14px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center">';
      lhtml += '<span style="font-size:12px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted)">Players</span>';
      lhtml += '<span style="font-size:11px;color:var(--green-accent)">&#9679; Live</span>';
      lhtml += '</div>';

      const sorted = roundData.players.slice().sort(function(a, b) {
        if (a === myName) return -1;
        if (b === myName) return 1;
        const aPlayed = roundData.scores[a].filter(s => s > 0).length;
        const bPlayed = roundData.scores[b].filter(s => s > 0).length;
        if (aPlayed === 0 && bPlayed === 0) return 0;
        if (aPlayed === 0) return 1;
        if (bPlayed === 0) return -1;
        const aDiff = roundData.scores[a].reduce((s, v) => s + v, 0) - course.holes.filter((h, i) => roundData.scores[a][i] > 0).reduce((a2, h) => a2 + h.par, 0);
        const bDiff = roundData.scores[b].reduce((s, v) => s + v, 0) - course.holes.filter((h, i) => roundData.scores[b][i] > 0).reduce((a2, h) => a2 + h.par, 0);
        return aDiff - bDiff;
      });

      sorted.forEach(function(p, idx) {
        const isMe = p === myName;
        const isAdmin = roundData._nameToUid && roundData._nameToUid[p] === roundData._createdBy;
        const scores = roundData.scores[p];
        const totalScore = scores.reduce((s, v) => s + v, 0);
        const holesPlayed = scores.filter(s => s > 0).length;
        const parPlayed = course.holes.filter((h, i) => scores[i] > 0).reduce((a, h) => a + h.par, 0);
        const diff = totalScore - parPlayed;
        let toPar = 'E';
        let toParColor = 'var(--text-muted)';
        if (holesPlayed === 0) { toPar = '\u2014'; }
        else if (diff < 0) { toPar = diff.toString(); toParColor = 'var(--green-accent)'; }
        else if (diff > 0) { toPar = '+' + diff; toParColor = 'var(--bogey)'; }

        const borderTop = idx > 0 ? 'border-top:1px solid var(--border);' : '';
        const meBg = isMe ? 'background:rgba(0,230,118,0.04);' : '';

        lhtml += '<div style="padding:10px 14px;display:flex;align-items:center;justify-content:space-between;' + borderTop + meBg + '">';
        lhtml += '<div style="display:flex;align-items:center;gap:10px;min-width:0;flex:1">';
        if (isMe) {
          lhtml += '<div style="width:26px;height:26px;border-radius:50%;background:var(--green-accent);color:#000;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:800;flex-shrink:0">YOU</div>';
        } else {
          lhtml += '<div style="width:26px;height:26px;border-radius:50%;background:var(--bg-elevated);color:var(--text-muted);display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;flex-shrink:0;border:1px solid var(--border)">' + p.charAt(0).toUpperCase() + '</div>';
        }
        lhtml += '<span style="font-weight:600;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + p + '</span>';
        if (isAdmin) {
          lhtml += '<span style="font-size:9px;font-weight:700;color:#f5a623;background:rgba(245,166,35,0.15);padding:2px 6px;border-radius:4px;letter-spacing:0.5px;flex-shrink:0">&#9733; ADMIN</span>';
        }
        lhtml += '</div>';
        lhtml += '<div style="display:flex;align-items:center;gap:12px;flex-shrink:0">';
        lhtml += '<span style="font-size:11px;color:var(--text-muted)">' + (holesPlayed > 0 ? 'Thru ' + holesPlayed : '\u2014') + '</span>';
        lhtml += '<span style="font-size:16px;font-weight:800;min-width:28px;text-align:right">' + (holesPlayed > 0 ? totalScore : '\u2014') + '</span>';
        lhtml += '<span style="font-size:13px;font-weight:700;min-width:32px;text-align:right;color:' + toParColor + '">' + toPar + '</span>';
        lhtml += '</div>';
        lhtml += '</div>';
      });

      lhtml += '</div>';
      return lhtml;
    }

    // Update only the players leaderboard without re-rendering the whole page
    function updatePlayersLeaderboard() {
      if (!R || !course_ref.current) return;
      const myName = R._uidToName[user.uid];
      const course = course_ref.current;
      const el = document.getElementById('playersLeaderboard');
      if (el) {
        const temp = document.createElement('div');
        temp.innerHTML = buildPlayersLeaderboard(R, course, myName);
        // Update innerHTML only ‚Äî keep the outer element stable to avoid reflow/scroll jump
        el.innerHTML = temp.firstElementChild.innerHTML;
      }
    }

    function renderGroup() {
      if (!R || !course_ref.current) return;
      const course = course_ref.current;
      const hole = course.holes[currentHole];
      const teeKey = R.tee;
      const yardage = hole[teeKey] || '‚Äî';
      const myName = R._uidToName[user.uid];
      const isCreator = R._createdBy === user.uid;
      const playableHole = getGroupPlayableHole();
      const isFutureHole = currentHole > playableHole;

      let html = '';

      // Group bar with code, connection status, and refresh
      html += `
        <div class="group-bar">
          <div>
            <span class="group-bar-code">${groupCode}</span>
            <span class="group-players-count">&bull; ${R.players.length} player${R.players.length !== 1 ? 's' : ''}</span>
          </div>
          <div style="display:flex;align-items:center;gap:8px">
            <button onclick="refreshGroup()" style="background:none;border:1px solid var(--border);border-radius:6px;color:var(--text-muted);padding:4px 10px;font-size:12px;cursor:pointer" title="Refresh">&#128260; Reload</button>
            <div class="connection-status ${isConnected ? 'online' : 'offline'}" id="connStatus">
              <span class="connection-dot"></span>${isConnected ? 'Live' : 'Offline'}
            </div>
          </div>
        </div>
      `;

      // Leaderboard link
      html += `<a href="live-game.html?group=${groupCode}" class="leaderboard-link">&#127942; View Full Leaderboard</a>`;

      // Hole strip
      html += '<div class="hole-strip" id="holeStrip">';
      for (let i = 0; i < 18; i++) {
        const anyScored = R.players.some(p => R.scores[p][i] > 0);
        let cls = i === currentHole ? 'active' : (anyScored ? 'scored' : '');
        if (i > playableHole && i !== currentHole) cls += ' future';
        html += `<div class="hole-pip ${cls}" onclick="goToHole(${i})">${i+1}</div>`;
      }
      html += '</div>';

      // Hole display
      html += `
        <div class="hole-display">
          <div class="hole-number">${isFutureHole ? 'Preview ‚Äî ' : ''}Hole ${hole.num}</div>
          <div class="hole-info-chips">
            <span class="info-chip par-chip">Par ${hole.par}</span>
            <span class="info-chip">${yardage} yds</span>
            <span class="info-chip">HCP ${hole.hcp}</span>
          </div>
        </div>
      `;

      // Future hole preview banner
      if (isFutureHole) {
        html += `<div class="preview-banner">
          <span class="preview-banner-icon">&#128065;</span>
          <div>
            <div class="preview-banner-title">Hole Preview</div>
            <div class="preview-banner-sub">You're previewing a future hole. Score input is available when you reach this hole.</div>
          </div>
          <button class="preview-back-btn" onclick="goToHole(${playableHole})">Go to Hole ${playableHole + 1} &#8594;</button>
        </div>`;
      }

      // Hole layout image
      if (hole.img) {
        html += `<div class="hole-layout-container" id="layoutContainerGroup">
          <div class="hole-layout-toggle" onclick="document.getElementById('layoutContainerGroup').classList.toggle('expanded')">
            <span class="layout-icon">üó∫Ô∏è</span>
            <span class="layout-label">View Hole Layout</span>
            <span class="layout-chevron">‚ñº</span>
          </div>
          <div class="hole-layout-img-wrap">
            <img src="${hole.img}" alt="Hole ${hole.num} layout" loading="lazy">
          </div>
        </div>`;
      }

      // YOUR score card ‚Äî only show if NOT a future hole
      if (!isFutureHole && myName) {
        const score = R.scores[myName][currentHole];
        const scoreClass = getScoreClass(score, hole.par);
        const label = getScoreLabel(score, hole.par);
        const t = R.tracking[myName];

        const totalScore = R.scores[myName].reduce((a, b) => a + b, 0);
        const holesPlayed = R.scores[myName].filter(s => s > 0).length;
        const parPlayed = course.holes.filter((h, i) => R.scores[myName][i] > 0).reduce((a, h) => a + h.par, 0);
        const diff = totalScore - parPlayed;
        let badgeClass = 'even', badgeText = 'E';
        if (holesPlayed === 0) { badgeText = '‚Äî'; }
        else if (diff < 0) { badgeClass = 'under'; badgeText = diff.toString(); }
        else if (diff > 0) { badgeClass = 'over'; badgeText = '+' + diff; }

        html += `<div class="player-score-card you-badge">`;
        html += `
          <div class="player-score-header">
            <span class="player-score-name">${myName}</span>
            <span class="player-total-badge ${badgeClass}">${holesPlayed > 0 ? totalScore + ' (' + badgeText + ')' : '‚Äî'}</span>
          </div>
        `;
        html += '<div class="score-stepper">';
        html += `<button class="step-btn minus" onclick="adj(-1)">&minus;</button>`;
        html += `<div class="score-big ${scoreClass}">${score}</div>`;
        html += `<button class="step-btn plus" onclick="adj(1)">+</button>`;
        html += '</div>';
        html += `<div class="score-label ${scoreClass}">${label}</div>`;

        html += '<div class="putts-row">';
        html += '<span class="putts-label">‚õ≥Ô∏è Putts</span>';
        html += '<div class="putt-stepper">';
        html += `<button class="putt-btn p-minus" onclick="adjPutt(-1)">&minus;</button>`;
        html += `<div class="putt-val">${t.putts[currentHole]}</div>`;
        html += `<button class="putt-btn p-plus" onclick="adjPutt(1)">+</button>`;
        html += '</div></div>';

        html += '<div class="putts-row mulligan-row">';
        html += '<span class="putts-label mulligan-label-text">üîÑ Mulligan</span>';
        html += '<div class="putt-stepper">';
        html += `<button class="putt-btn p-minus mulligan-btn" onclick="adjMulligan(-1)">&minus;</button>`;
        html += `<div class="putt-val mulligan-val">${t.mulligans[currentHole]}</div>`;
        html += `<button class="putt-btn p-plus mulligan-btn" onclick="adjMulligan(1)">+</button>`;
        html += '</div></div>';

        html += '<div class="putts-row penalty-row">';
        html += '<span class="putts-label penalty-label-text">ü´≥üèº Drop</span>';
        html += '<div class="putt-stepper">';
        html += `<button class="putt-btn p-minus penalty-btn" onclick="adjPenalty(-1)">&minus;</button>`;
        html += `<div class="putt-val penalty-val">${t.penalties[currentHole]}</div>`;
        html += `<button class="putt-btn p-plus penalty-btn" onclick="adjPenalty(1)">+</button>`;
        html += '</div></div>';

        html += '</div>'; // close player card
      }

      // Hole nav buttons ‚Äî right under YOUR score counter
      if (!isFutureHole) {
        html += '<div class="hole-nav-row">';
        if (currentHole > 0) {
          html += `<button class="hole-nav-btn prev" onclick="goToHole(${currentHole - 1})">&larr; Hole ${currentHole}</button>`;
        } else {
          html += '<div></div>';
        }
        if (currentHole < 17) {
          html += `<button class="hole-nav-btn next" onclick="goToHole(${currentHole + 1})">Hole ${currentHole + 2} &rarr;</button>`;
        } else {
          html += `<button class="hole-nav-btn next" onclick="finishGroupRoundAction()" style="background:var(--gold);color:#1a1a1a;">Finish Round</button>`;
        }
        html += '</div>';
      }

      // Live players leaderboard ‚Äî updates in real-time
      html += buildPlayersLeaderboard(R, course, myName);


      // Share code ‚Äî right above finish/leave
      html += `
        <div class="group-code-display" style="padding:12px; margin-bottom:12px;">
          <div class="group-code-label">Share Code</div>
          <div class="group-code" style="font-size:28px">${groupCode}</div>
          <div class="group-code-actions">
            <button class="copy-code-btn" onclick="copyCode()">Copy Code</button>
          </div>
        </div>
      `;

      // Finish / Leave ‚Äî every player can save their own round
      if (!isFutureHole) {
        html += '<div class="finish-section">';
        html += '<button class="btn-gold" onclick="finishGroupRoundAction()">Save & Finish</button>';
        if (R._createdBy === user.uid) {
          html += '<button class="btn-danger" onclick="endRoundForAll()" style="background:#c0392b;color:#fff;border:none;padding:12px 24px;border-radius:var(--radius);font-weight:700;font-size:14px;cursor:pointer;width:100%">End Round for All</button>';
        }
        html += '<button class="btn-secondary" onclick="leaveGroupRound()">Leave</button>';
        html += '</div>';
      }

      document.getElementById('mainContent').innerHTML = html;

      setTimeout(() => {
        const strip = document.getElementById('holeStrip');
        const activePip = strip?.querySelector('.hole-pip.active');
        if (activePip && strip) {
          activePip.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
        }
      }, 50);
    }

    // ===== Surgical DOM updates (no full re-render, no scroll jump) =====
    function updateScoreDisplay() {
      if (!R || !course_ref.current) return;
      const course = course_ref.current;
      const hole = course.holes[currentHole];
      const myName = R._uidToName[user.uid];
      if (!myName) return;

      const score = R.scores[myName][currentHole];
      const scoreClass = getScoreClass(score, hole.par);
      const label = getScoreLabel(score, hole.par);

      // Update big score number
      const scoreBig = document.querySelector('.score-big');
      if (scoreBig) { scoreBig.textContent = score; scoreBig.className = 'score-big ' + scoreClass; }

      // Update score label
      const scoreLabel = document.querySelector('.score-label');
      if (scoreLabel) { scoreLabel.textContent = label; scoreLabel.className = 'score-label ' + scoreClass; }

      // Update total badge
      const totalScore = R.scores[myName].reduce((a, b) => a + b, 0);
      const holesPlayed = R.scores[myName].filter(s => s > 0).length;
      const parPlayed = course.holes.filter((h, i) => R.scores[myName][i] > 0).reduce((a, h) => a + h.par, 0);
      const diff = totalScore - parPlayed;
      let badgeClass = 'even', badgeText = 'E';
      if (holesPlayed === 0) { badgeText = '‚Äî'; }
      else if (diff < 0) { badgeClass = 'under'; badgeText = diff.toString(); }
      else if (diff > 0) { badgeClass = 'over'; badgeText = '+' + diff; }

      const badge = document.querySelector('.player-total-badge');
      if (badge) {
        badge.className = 'player-total-badge ' + badgeClass;
        badge.textContent = holesPlayed > 0 ? totalScore + ' (' + badgeText + ')' : '‚Äî';
      }
    }

    function updateTrackingDisplay() {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const mulliganVal = document.querySelector('.mulligan-val');
      if (mulliganVal) mulliganVal.textContent = R.tracking[myName].mulligans[currentHole];
    }

    function updatePenaltyDisplay() {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const penaltyVal = document.querySelector('.penalty-val');
      if (penaltyVal) penaltyVal.textContent = R.tracking[myName].penalties[currentHole];
    }

    function updatePuttDisplay() {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const puttVal = document.querySelector('.putt-val');
      if (puttVal) puttVal.textContent = R.tracking[myName].putts[currentHole];
    }

    // ===== Group actions (write to Firebase per-UID) =====
    // Check for pending drop locations in group mode, then advance
    function checkDropsThenAdvanceGroup(idx) {
      var myName = R && R._uidToName ? R._uidToName[user.uid] : null;
      if (myName && R.tracking[myName]) {
        var count = R.tracking[myName].penalties[currentHole];
        var pl = R.tracking[myName].penaltyLocations;
        if (count > 0 && !(pl && pl[currentHole])) {
          var holeAtPrompt = currentHole;
          var name = myName;
          if (!R.tracking[name].penaltyLocations) {
            R.tracking[name].penaltyLocations = new Array(18).fill(null);
          }
          _dropConfirmCallback = function(locations) {
            R.tracking[name].penaltyLocations[holeAtPrompt] = locations;
            updateGroupTracking(groupCode, user.uid, 'penaltyLocations', holeAtPrompt, locations);
            proceedToHoleGroup(idx);
          };
          showDropModal(name, count, currentHole);
          return;
        }
      }
      proceedToHoleGroup(idx);
    }

    window.goToHole = function(idx) {
      // Check if moving forward ‚Äî prompt for mulligan locations, then drop locations
      if (idx > currentHole) {
        var myName = R && R._uidToName ? R._uidToName[user.uid] : null;
        if (myName && R.tracking[myName]) {
          var count = R.tracking[myName].mulligans[currentHole];
          var ml = R.tracking[myName].mulliganLocations;
          if (count > 0 && !(ml && ml[currentHole])) {
            var holeAtPrompt = currentHole;
            var name = myName;
            if (!R.tracking[name].mulliganLocations) {
              R.tracking[name].mulliganLocations = new Array(18).fill(null);
            }
            _mulliganConfirmCallback = function(locations) {
              R.tracking[name].mulliganLocations[holeAtPrompt] = locations;
              updateGroupTracking(groupCode, user.uid, 'mulliganLocations', holeAtPrompt, locations);
              checkDropsThenAdvanceGroup(idx);
            };
            showMulliganModal(name, count, currentHole);
            return;
          }
        }
        // No mulligans pending ‚Äî check drops
        checkDropsThenAdvanceGroup(idx);
        return;
      }
      proceedToHoleGroup(idx);
    };

    function proceedToHoleGroup(idx) {
      // Show score effect when moving forward, wait for it to finish
      if (idx > currentHole && R && R._uidToName) {
        var myName = R._uidToName[user.uid];
        var c = course_ref.current;
        if (myName && R.scores[myName] && c) {
          var prevPar = c.holes[currentHole].par;
          var prevScore = R.scores[myName][currentHole];
          if (prevScore > 0) {
            showScoreEffect(prevScore, prevPar, function() {
              currentHole = idx;
              renderGroup();
              window.scrollTo({ top: 0, behavior: 'smooth' });
            });
            return;
          }
        }
      }
      currentHole = idx;
      renderGroup();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    window.adj = function(delta) {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const current = R.scores[myName][currentHole];
      const next = Math.max(0, Math.min(15, current + delta));
      R.scores[myName][currentHole] = next;
      updateScoreDisplay();
      updateGroupScore(groupCode, user.uid, currentHole, next);
    };

    window.adjPutt = function(delta) {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const current = R.tracking[myName].putts[currentHole];
      const next = Math.max(0, Math.min(10, current + delta));
      R.tracking[myName].putts[currentHole] = next;
      updatePuttDisplay();
      updateGroupTracking(groupCode, user.uid, 'putts', currentHole, next);
    };

    window.toggleTrack = function(type) {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const current = R.tracking[myName][type][currentHole];
      R.tracking[myName][type][currentHole] = !current;
      updateTrackingDisplay();
      updateGroupTracking(groupCode, user.uid, type, currentHole, !current);
    };

    window.adjMulligan = function(delta) {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      var current = R.tracking[myName].mulligans[currentHole];
      const next = Math.max(0, Math.min(5, current + delta));
      R.tracking[myName].mulligans[currentHole] = next;
      if (!R.tracking[myName].mulliganLocations) R.tracking[myName].mulliganLocations = new Array(18).fill(null);
      R.tracking[myName].mulliganLocations[currentHole] = null;
      updateTrackingDisplay();
      updateGroupTracking(groupCode, user.uid, 'mulligans', currentHole, next);
      updateGroupTracking(groupCode, user.uid, 'mulliganLocations', currentHole, null);
    };

    window.adjPenalty = function(delta) {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const current = R.tracking[myName].penalties[currentHole];
      const next = Math.max(0, Math.min(10, current + delta));
      R.tracking[myName].penalties[currentHole] = next;
      if (!R.tracking[myName].penaltyLocations) R.tracking[myName].penaltyLocations = new Array(18).fill(null);
      R.tracking[myName].penaltyLocations[currentHole] = null;
      updatePenaltyDisplay();
      updateGroupTracking(groupCode, user.uid, 'penalties', currentHole, next);
      updateGroupTracking(groupCode, user.uid, 'penaltyLocations', currentHole, null);
    };

    window.refreshGroup = function() {
      // Full page reload to ensure everything is fresh
      window.location.reload();
    };

    window.copyCode = function() {
      navigator.clipboard.writeText(groupCode).then(() => {
        const btn = document.querySelector('.copy-code-btn');
        if (btn) { btn.textContent = 'Copied!'; setTimeout(() => btn.textContent = 'Copy Code', 2000); }
      }).catch(() => {
        prompt('Copy this code:', groupCode);
      });
    };

    window.finishGroupRoundAction = function() {
      if (!R) return;
      const myName = R._uidToName[user.uid];
      if (!myName) return;
      const myScored = R.scores[myName].some(s => s > 0);
      if (!myScored) { alert('No scores entered yet.'); return; }

      const myHolesPlayed = R.scores[myName].filter(s => s > 0).length;
      const isIncomplete = myHolesPlayed < 18;
      const confirmMsg = isIncomplete
        ? 'You only played ' + myHolesPlayed + '/18 holes. Save as incomplete round?'
        : 'Save your round and finish?';
      if (!confirm(confirmMsg)) return;

      // Save a personal copy ‚Äî does NOT end the round for others
      const course = course_ref.current;
      if (course) {
        // Build holesCompleted per player
        const holesCompleted = {};
        R.players.forEach(function(p) {
          holesCompleted[p] = R.scores[p].filter(s => s > 0).length;
        });

        const round = {
          id: Date.now().toString(),
          courseId: course.id,
          courseName: course.name,
          tee: R.tee,
          teeLabel: R.teeLabel,
          par: course.par,
          date: R.date,
          players: [...R.players],
          scores: JSON.parse(JSON.stringify(R.scores)),
          tracking: JSON.parse(JSON.stringify(R.tracking)),
          holePars: course.holes.map(h => h.par),
          groupCode: groupCode,
          holesCompleted: holesCompleted,
          incomplete: isIncomplete
        };

        // Save to Firebase cloud
        fbSaveRound(user.uid, round).catch(() => {});

        // Also save to localStorage as backup
        const rounds = loadRounds();
        rounds.push(round);
        saveRounds(rounds);
      }

      // Mark this player as finished in Firebase, then check if everyone is done
      markPlayerFinished(groupCode, user.uid).then(function() {
        return checkAndCleanupRound(groupCode);
      }).catch(function() {}).then(function() {
        // Clean up listeners but keep group code so LIVE tab still works
        if (unsubscribe) unsubscribe();
        if (unsubConn) unsubConn();
        // Redirect to live spectator view so they can watch others finish
        window.location.href = 'live-game.html?group=' + groupCode;
      });
    };

    window.endRoundForAll = function() {
      if (!R) return;
      if (R._createdBy !== user.uid) { alert('Only the admin can end the round.'); return; }
      if (!confirm('End the round for all players? Everyone\'s scores will be saved as-is.')) return;

      // Save admin's own scores to history
      const course = course_ref.current;
      if (course) {
        const holesCompleted = {};
        R.players.forEach(function(p) {
          holesCompleted[p] = R.scores[p].filter(s => s > 0).length;
        });

        const myName = R._uidToName[user.uid];
        const myHolesPlayed = myName ? R.scores[myName].filter(s => s > 0).length : 0;

        const round = {
          id: Date.now().toString(),
          courseId: course.id,
          courseName: course.name,
          tee: R.tee,
          teeLabel: R.teeLabel,
          par: course.par,
          date: R.date,
          players: [...R.players],
          scores: JSON.parse(JSON.stringify(R.scores)),
          tracking: JSON.parse(JSON.stringify(R.tracking)),
          holePars: course.holes.map(h => h.par),
          groupCode: groupCode,
          holesCompleted: holesCompleted,
          incomplete: myHolesPlayed < 18
        };

        fbSaveRound(user.uid, round).catch(() => {});
        const rounds = loadRounds();
        rounds.push(round);
        saveRounds(rounds);
      }

      // Set status to 'ended' ‚Äî triggers all other players' listeners to save & exit
      endGroupRoundForAll(groupCode).catch(function() {}).then(function() {
        if (unsubscribe) unsubscribe();
        if (unsubConn) unsubConn();
        localStorage.removeItem('active-group-code');
        window.location.href = 'history.html';
      });
    };

    window.leaveGroupRound = function() {
      if (confirm('Leave without saving?')) {
        if (unsubscribe) unsubscribe();
        if (unsubConn) unsubConn();
        localStorage.removeItem('active-group-code');
        window.location.href = 'index.html';
      }
    };
  }
</script>
</body>
</html>
